<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šäººåœ¨çº¿å¾·å·æ‰‘å…‹</title>
    <!-- PeerJSåº“ -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: linear-gradient(90deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* æ¸¸æˆæ¨¡å¼é€‰æ‹© */
        .mode-selector {
            text-align: center;
            margin-bottom: 30px;
        }

        .mode-btn {
            padding: 15px 40px;
            font-size: 1.2em;
            font-weight: bold;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s;
        }

        .mode-btn.local {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
        }

        .mode-btn.online {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .mode-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        /* æ¸¸æˆå¤§å… */
        .lobby-panel {
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            margin: 50px auto;
            text-align: center;
        }

        .lobby-panel h2 {
            color: #ffd700;
            margin-bottom: 30px;
            font-size: 2em;
        }

        .lobby-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
        }

        .tab-btn {
            padding: 12px 30px;
            font-size: 1em;
            font-weight: bold;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 25px;
            background: transparent;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #1a1a2e;
            border-color: #ffd700;
        }

        .tab-btn:hover {
            border-color: #ffd700;
        }

        .lobby-input {
            width: 100%;
            padding: 15px 20px;
            font-size: 1.1em;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            margin: 10px 0;
            outline: none;
        }

        .lobby-input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .lobby-input:focus {
            border-color: #ffd700;
        }

        .lobby-btn {
            width: 100%;
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #1a1a2e;
            cursor: pointer;
            margin-top: 15px;
            transition: transform 0.3s;
        }

        .lobby-btn:hover {
            transform: scale(1.02);
        }

        .lobby-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* ç­‰å¾…æˆ¿é—´ */
        .waiting-room {
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            padding: 40px;
            max-width: 700px;
            margin: 50px auto;
            text-align: center;
        }

        .waiting-room h2 {
            color: #ffd700;
            margin-bottom: 20px;
        }

        .room-info {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .room-info p {
            margin: 10px 0;
            font-size: 1.1em;
        }

        .room-info strong {
            color: #ffd700;
        }

        .room-info input {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 1em;
        }

        .players-list {
            margin: 20px 0;
            min-height: 150px;
        }

        .player-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-item .player-name {
            font-size: 1.2em;
            color: #ffd700;
        }

        .player-item .player-status {
            font-size: 0.9em;
            color: #2ecc71;
        }

        .player-item .is-host::after {
            content: ' (æˆ¿ä¸»)';
            color: #e74c3c;
        }

        .connection-status {
            padding: 10px 20px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: 0.9em;
        }

        .connection-status.connected {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .connection-status.connecting {
            background: rgba(241, 196, 15, 0.2);
            color: #f1c40f;
        }

        .connection-status.error {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        /* å•æœºæ¨¡å¼é¢æ¿ */
        .setup-panel {
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            margin: 50px auto;
            text-align: center;
        }

        .setup-panel h2 {
            color: #ffd700;
            margin-bottom: 30px;
            font-size: 2em;
        }

        .setup-option {
            margin: 20px 0;
        }

        .setup-option label {
            display: block;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .setup-option input[type="range"] {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
        }

        .setup-option input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
        }

        .player-count-display {
            font-size: 2em;
            color: #ffd700;
            font-weight: bold;
        }

        .player-config-list {
            margin: 20px 0;
            text-align: left;
        }

        .player-config-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-config-item label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .player-config-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-left: 10px;
        }

        .btn-start {
            margin-top: 20px;
            padding: 15px 50px;
            font-size: 1.3em;
            font-weight: bold;
            border: none;
            border-radius: 30px;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #1a1a2e;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .btn-start:hover {
            transform: scale(1.05);
        }

        /* æ¸¸æˆç•Œé¢ */
        .game-area {
            display: none;
        }

        .game-info {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        .game-info span {
            margin: 0 20px;
            color: #ffd700;
        }

        .back-btn {
            padding: 8px 15px;
            border-radius: 15px;
            border: none;
            background: #e74c3c;
            color: white;
            cursor: pointer;
            font-size: 0.9em;
        }

        /* ç¯å½¢å¸ƒå±€ */
        .poker-table-container {
            position: relative;
            width: 100%;
            height: 600px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .poker-table {
            position: absolute;
            width: 400px;
            height: 400px;
            background: radial-gradient(ellipse at center, #2d5a27 0%, #1e3d1a 100%);
            border-radius: 50%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5), inset 0 0 100px rgba(0,0,0,0.3);
            border: 15px solid #4a2c18;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1;
        }

        .table-center {
            text-align: center;
        }

        .pot-display {
            font-size: 1.8em;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        .community-cards {
            display: flex;
            justify-content: center;
            gap: 10px;
            min-height: 100px;
        }

        .card {
            width: 60px;
            height: 84px;
            background: linear-gradient(145deg, #fff 0%, #f0f0f0 100%);
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            position: relative;
        }

        .card.red {
            color: #e74c3c;
        }

        .card.black {
            color: #2c3e50;
        }

        .card-suit {
            font-size: 24px;
        }

        .card-rank {
            font-size: 20px;
        }

        .card-back {
            background: linear-gradient(135deg, #c0392b 0%, #e74c3c 50%, #c0392b 100%);
            background-size: 15px 15px;
        }

        .card-back::before {
            content: 'ğŸ‚ ';
            font-size: 40px;
            color: #fff;
            opacity: 0.3;
        }

        .phase-display {
            margin-top: 15px;
            font-size: 1.2em;
            color: #fff;
        }

        /* ç©å®¶åº§ä½ */
        .player-seat {
            position: absolute;
            width: 180px;
            background: rgba(0,0,0,0.7);
            border-radius: 15px;
            padding: 15px;
            border: 2px solid rgba(255,255,255,0.2);
            transition: all 0.3s;
            z-index: 2;
        }

        .player-seat.active {
            border-color: #ffd700;
            box-shadow: 0 0 30px rgba(255,215,0,0.5);
            transform: scale(1.1);
        }

        .player-seat.folded {
            opacity: 0.4;
        }

        .player-seat.dealer .player-name::after {
            content: ' ğŸ´';
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .player-name {
            font-size: 1.1em;
            color: #ffd700;
            font-weight: bold;
        }

        .player-chips {
            font-size: 1em;
            color: #fff;
        }

        .player-cards {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-bottom: 8px;
            min-height: 45px;
        }

        .player-cards .card {
            width: 40px;
            height: 56px;
            font-size: 14px;
        }

        .player-cards .card-suit {
            font-size: 18px;
        }

        .player-cards .card-rank {
            font-size: 16px;
        }

        .player-bet {
            text-align: center;
            font-size: 1em;
            color: #2ecc71;
        }

        .player-action {
            text-align: center;
            font-size: 0.9em;
            color: #fff;
            margin-top: 5px;
            min-height: 20px;
        }

        /* æ§åˆ¶æŒ‰é’® */
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .controls button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .btn-fold {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .btn-check {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
        }

        .btn-call {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .btn-raise {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }

        .btn-allin {
            background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
            color: white;
        }

        .controls button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .controls button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        /* æ¶ˆæ¯æ˜¾ç¤º */
        .message-area {
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            min-height: 50px;
            font-size: 1.1em;
        }

        /* æ‰‹ç‰Œå¼ºåº¦æ˜¾ç¤º */
        .hand-strength {
            text-align: center;
            margin-top: 10px;
            font-size: 1em;
            color: #2ecc71;
        }

        /* å“åº”å¼ */
        @media (max-width: 768px) {
            .poker-table {
                width: 300px;
                height: 300px;
            }

            .player-seat {
                width: 140px;
                padding: 10px;
            }

            .card {
                width: 50px;
                height: 70px;
            }

            .controls button {
                padding: 12px 20px;
                font-size: 14px;
            }
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸƒ å¤šäººå¾·å·æ‰‘å…‹ ğŸƒ</h1>

        <!-- æ¨¡å¼é€‰æ‹© -->
        <div class="mode-selector" id="mode-selector">
            <button class="mode-btn local" onclick="selectMode('local')">ğŸ® å•æœºæ¨¡å¼</button>
            <button class="mode-btn online" onclick="selectMode('online')">ğŸŒ åœ¨çº¿å¯¹æˆ˜</button>
        </div>

        <!-- å•æœºæ¨¡å¼é…ç½®é¢æ¿ -->
        <div class="setup-panel hidden" id="setup-panel">
            <h2>æ¸¸æˆè®¾ç½®</h2>
            <div class="setup-option">
                <label>ç©å®¶æ•°é‡</label>
                <input type="range" id="player-count" min="2" max="10" value="4" oninput="updatePlayerCount()">
                <div class="player-count-display"><span id="player-count-display">4</span> äºº</div>
            </div>
            <div class="player-config-list" id="player-config-list">
                <!-- åŠ¨æ€ç”Ÿæˆ -->
            </div>
            <button class="btn-start" onclick="startLocalGame()">å¼€å§‹æ¸¸æˆ</button>
        </div>

        <!-- åœ¨çº¿æ¨¡å¼å¤§å… -->
        <div class="lobby-panel hidden" id="lobby-panel">
            <h2>ğŸ® æ¸¸æˆå¤§å…</h2>
            <div class="lobby-tabs">
                <button class="tab-btn active" onclick="showLobbyTab('create')">åˆ›å»ºæˆ¿é—´</button>
                <button class="tab-btn" onclick="showLobbyTab('join')">åŠ å…¥æˆ¿é—´</button>
            </div>
            <div id="create-room-tab">
                <input type="text" id="player-name" class="lobby-input" placeholder="è¾“å…¥ä½ çš„æ˜µç§°" maxlength="20">
                <button class="lobby-btn" onclick="createRoom()">åˆ›å»ºæˆ¿é—´</button>
            </div>
            <div id="join-room-tab" class="hidden">
                <input type="text" id="join-player-name" class="lobby-input" placeholder="è¾“å…¥ä½ çš„æ˜µç§°" maxlength="20">
                <input type="text" id="room-code-input" class="lobby-input" placeholder="è¾“å…¥æˆ¿é—´ç " maxlength="6" style="text-transform: uppercase;">
                <button class="lobby-btn" onclick="joinRoom()">åŠ å…¥æˆ¿é—´</button>
            </div>
            <div id="connection-status" class="connection-status connecting">æ­£åœ¨è¿æ¥PeerJSæœåŠ¡å™¨...</div>
        </div>

        <!-- ç­‰å¾…æˆ¿é—´ -->
        <div class="waiting-room hidden" id="waiting-room">
            <h2>ç­‰å¾…å…¶ä»–ç©å®¶åŠ å…¥...</h2>
            <div class="room-info">
                <p>æˆ¿é—´ç : <strong id="display-room-code">-</strong></p>
                <p>å¤åˆ¶é“¾æ¥åˆ†äº«ç»™æœ‹å‹:</p>
                <input type="text" id="share-link" readonly onclick="this.select()">
            </div>
            <div class="players-list" id="players-list">
                <!-- åŠ¨æ€ç”Ÿæˆ -->
            </div>
            <div id="host-controls" class="hidden">
                <button class="lobby-btn" onclick="startOnlineGame()" id="start-online-btn" disabled>å¼€å§‹æ¸¸æˆ</button>
            </div>
            <div id="guest-message" class="hidden" style="color: #f1c40f; margin-top: 20px;">
                ç­‰å¾…æˆ¿ä¸»å¼€å§‹æ¸¸æˆ...
            </div>
        </div>

        <!-- æ¸¸æˆåŒºåŸŸ -->
        <div class="game-area" id="game-area">
            <div class="game-info">
                <span>å›åˆ: <span id="round-num">1</span></span>
                <span>å°ç›²: <span id="small-blind">10</span></span>
                <span>å¤§ç›²: <span id="big-blind">20</span></span>
                <button class="back-btn" onclick="exitGame()">é€€å‡ºæ¸¸æˆ</button>
            </div>

            <div class="poker-table-container">
                <div class="poker-table">
                    <div class="table-center">
                        <div class="pot-display">åº•æ± : <span id="pot">0</span></div>
                        <div class="community-cards" id="community-cards">
                            <div class="card card-back"></div>
                            <div class="card card-back"></div>
                            <div class="card card-back"></div>
                            <div class="card card-back"></div>
                            <div class="card card-back"></div>
                        </div>
                        <div class="phase-display" id="phase-display">ç­‰å¾…å¼€å§‹</div>
                    </div>
                </div>
                <div id="player-seats">
                    <!-- åŠ¨æ€ç”Ÿæˆç©å®¶åº§ä½ -->
                </div>
            </div>

            <div class="hand-strength" id="hand-strength"></div>

            <div class="message-area" id="message">ç­‰å¾…æ¸¸æˆå¼€å§‹...</div>

            <div class="controls">
                <button class="btn-fold" onclick="playerAction('fold')" id="btn-fold" disabled>å¼ƒç‰Œ</button>
                <button class="btn-check" onclick="playerAction('check')" id="btn-check" disabled>è¿‡ç‰Œ</button>
                <button class="btn-call" onclick="playerAction('call')" id="btn-call" disabled>è·Ÿæ³¨ <span id="call-amount"></span></button>
                <button class="btn-raise" onclick="playerAction('raise')" id="btn-raise" disabled>åŠ æ³¨ 50</button>
                <button class="btn-allin" onclick="playerAction('allin')" id="btn-allin" disabled>å…¨æŠ¼</button>
                <button class="btn-start" onclick="requestNewGame()" id="btn-new-game" style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);">ä¸‹ä¸€å±€</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== å¸¸é‡å®šä¹‰ ====================
        const SUITS = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const RANK_VALUES = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14};

        const MESSAGE_TYPES = {
            JOIN: 'join',
            WELCOME: 'welcome',
            PLAYER_JOINED: 'player_joined',
            PLAYER_LEFT: 'player_left',
            GAME_START: 'game_start',
            ACTION: 'action',
            STATE_UPDATE: 'state_update',
            NEW_GAME: 'new_game',
            NEW_GAME_REQUEST: 'new_game_request'
        };

        const AI_PERSONALITIES = [
            { name: 'ä¿å®ˆå‹', aggression: 0.2, bluffChance: 0.05, foldThreshold: 0.3 },
            { name: 'å¹³è¡¡å‹', aggression: 0.5, bluffChance: 0.2, foldThreshold: 0.2 },
            { name: 'æ¿€è¿›å‹', aggression: 0.8, bluffChance: 0.4, foldThreshold: 0.1 }
        ];

        // ==================== å…¨å±€çŠ¶æ€ ====================
        let gameMode = null; // 'local' or 'online'
        let myPlayerName = '';
        let isHost = false;
        let localPlayerIndex = 0;

        // PeerJS ç›¸å…³
        let peer = null;
        let hostConnection = null;
        let playerConnections = [];
        let myPeerId = null;
        let roomId = null;

        // æ¸¸æˆé…ç½®
        let gameConfig = {
            totalPlayers: 4,
            humanPlayers: [0],
            smallBlind: 10,
            bigBlind: 20,
            startingChips: 1000
        };

        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            phase: 'idle',
            round: 0,
            pot: 0,
            currentBet: 0,
            minRaise: 20,
            currentPlayerIndex: 0,
            dealerIndex: 0,
            lastRaiser: -1,
            players: [],
            deck: [],
            communityCards: []
        };

        // ==================== ç©å®¶ç±» ====================
        class Player {
            constructor(id, name, isLocal = false, isHuman = false, chips = 1000) {
                this.id = id;
                this.name = name;
                this.isLocal = isLocal;
                this.isHuman = isHuman;
                this.chips = chips;
                this.initialChips = chips;
                this.cards = [];
                this.currentBet = 0;
                this.folded = false;
                this.allIn = false;
                this.lastAction = '';
                this.personality = null;
            }

            reset() {
                this.cards = [];
                this.currentBet = 0;
                this.folded = false;
                this.allIn = false;
                this.lastAction = '';
            }
        }

        // ==================== æ¨¡å¼é€‰æ‹© ====================
        function selectMode(mode) {
            gameMode = mode;
            document.getElementById('mode-selector').classList.add('hidden');

            if (mode === 'local') {
                document.getElementById('setup-panel').classList.remove('hidden');
                updatePlayerCount();
            } else {
                document.getElementById('lobby-panel').classList.remove('hidden');
                initPeer();
            }
        }

        function showLobbyTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            if (tab === 'create') {
                document.getElementById('create-room-tab').classList.remove('hidden');
                document.getElementById('join-room-tab').classList.add('hidden');
            } else {
                document.getElementById('create-room-tab').classList.add('hidden');
                document.getElementById('join-room-tab').classList.remove('hidden');
            }
        }

        // ==================== PeerJS åˆå§‹åŒ– ====================
        function initPeer() {
            updateConnectionStatus('connecting', 'æ­£åœ¨è¿æ¥PeerJSæœåŠ¡å™¨...');

            // ä½¿ç”¨è‡ªå®šä¹‰çš„PeerJSé…ç½®æé«˜ç¨³å®šæ€§
            peer = new Peer(null, {
                debug: 1,
                // ä½¿ç”¨å¤šä¸ªå¤‡ç”¨æœåŠ¡å™¨æé«˜å¯ç”¨æ€§
            });

            peer.on('open', (id) => {
                myPeerId = id;
                console.log('My peer ID:', id);
                updateConnectionStatus('connected', 'å·²è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œå¯ä»¥åˆ›å»º/åŠ å…¥æˆ¿é—´');
            });

            peer.on('connection', (conn) => {
                console.log('New connection from:', conn.peer);
                if (isHost) {
                    handlePlayerConnection(conn);
                }
            });

            peer.on('error', (err) => {
                console.error('PeerJS error:', err);
                let errorMsg = 'PeerJSè¿æ¥å¤±è´¥';

                if (err.type === 'peer-unavailable') {
                    errorMsg = 'æ— æ³•è¿æ¥åˆ°PeerJSæœåŠ¡ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ';
                } else if (err.type === 'ssl-unavailable') {
                    errorMsg = 'éœ€è¦HTTPSè¿æ¥';
                } else if (err.type === 'server-error') {
                    errorMsg = 'PeerJSæœåŠ¡å™¨é”™è¯¯ï¼Œè¯·åˆ·æ–°é‡è¯•';
                } else if (err.type === 'network') {
                    errorMsg = 'ç½‘ç»œè¿æ¥å¤±è´¥';
                }

                updateConnectionStatus('error', errorMsg);
                showMessage(errorMsg + 'ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
            });

            peer.on('disconnected', () => {
                console.log('PeerJS disconnected, attempting to reconnect...');
                updateConnectionStatus('connecting', 'è¿æ¥å·²æ–­å¼€ï¼Œæ­£åœ¨é‡è¿...');
                // å°è¯•é‡æ–°è¿æ¥
                if (peer && !peer.destroyed) {
                    peer.reconnect();
                }
            });
        }

        function updateConnectionStatus(status, message) {
            const statusDiv = document.getElementById('connection-status');
            if (statusDiv) {
                statusDiv.className = 'connection-status ' + status;
                statusDiv.textContent = message;
            }
        }

        // ==================== æˆ¿é—´ç®¡ç† ====================
        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function createRoom() {
            const nameInput = document.getElementById('player-name');
            myPlayerName = nameInput.value.trim();

            if (!myPlayerName) {
                showMessage('è¯·è¾“å…¥æ˜µç§°');
                return;
            }

            // æ£€æŸ¥PeerJSæ˜¯å¦å·²è¿æ¥
            if (!peer || !myPeerId) {
                showMessage('è¯·ç­‰å¾…PeerJSæœåŠ¡å™¨è¿æ¥æˆåŠŸåå†åˆ›å»ºæˆ¿é—´');
                return;
            }

            // æ£€æŸ¥PeerJSè¿æ¥çŠ¶æ€
            if (peer.destroyed) {
                showMessage('PeerJSè¿æ¥å·²æ–­å¼€ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                return;
            }

            isHost = true;
            roomId = generateRoomCode();

            // åˆ›å»ºæˆ¿ä¸»ç©å®¶
            gameState.players = [new Player(0, myPlayerName, true, true)];
            localPlayerIndex = 0;

            // æ˜¾ç¤ºç­‰å¾…æˆ¿é—´
            showWaitingRoom();
        }

        function joinRoom() {
            const nameInput = document.getElementById('join-player-name');
            const roomInput = document.getElementById('room-code-input');
            myPlayerName = nameInput.value.trim();
            const roomCode = roomInput.value.trim().toUpperCase();

            if (!myPlayerName || !roomCode) {
                showMessage('è¯·è¾“å…¥æ˜µç§°å’Œæˆ¿é—´ç ');
                return;
            }

            if (!peer || !myPeerId) {
                showMessage('è¯·ç­‰å¾…è¿æ¥æœåŠ¡å™¨');
                return;
            }

            isHost = false;
            roomId = roomCode;

            // æ£€æŸ¥URLå‚æ•°
            const urlParams = new URLSearchParams(window.location.search);
            const hostId = urlParams.get('host');

            if (!hostId) {
                showMessage('æ— æ•ˆçš„é‚€è¯·é“¾æ¥');
                return;
            }

            // ç¦ç”¨åŠ å…¥æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
            const joinBtn = document.querySelector('#join-room-tab .lobby-btn');
            if (joinBtn) joinBtn.disabled = true;

            showMessage('æ­£åœ¨åŠ å…¥æˆ¿é—´...');

            // è¿æ¥è¶…æ—¶å¤„ç†
            let connectionTimeout = setTimeout(() => {
                if (hostConnection && !hostConnection.open) {
                    hostConnection.close();
                    showMessage('è¿æ¥è¶…æ—¶ï¼šæˆ¿ä¸»å¯èƒ½ä¸åœ¨çº¿ï¼Œè¯·ç¡®è®¤æˆ¿ä¸»å·²åˆ›å»ºæˆ¿é—´');
                    if (joinBtn) joinBtn.disabled = false;
                }
            }, 15000);

            // è¿æ¥åˆ°æˆ¿ä¸»
            hostConnection = peer.connect(hostId, {
                metadata: { playerName: myPlayerName, roomId: roomCode },
                reliable: true
            });

            hostConnection.on('open', () => {
                clearTimeout(connectionTimeout);
                console.log('Connected to host');
                updateConnectionStatus('connected', 'å·²è¿æ¥åˆ°æˆ¿ä¸»');
                // å‘é€åŠ å…¥è¯·æ±‚
                hostConnection.send({
                    type: MESSAGE_TYPES.JOIN,
                    playerName: myPlayerName,
                    peerId: myPeerId
                });
            });

            hostConnection.on('data', (data) => {
                handleHostMessage(data);
            });

            hostConnection.on('close', () => {
                clearTimeout(connectionTimeout);
                showMessage('ä¸æˆ¿ä¸»çš„è¿æ¥å·²æ–­å¼€ï¼Œæˆ¿ä¸»å¯èƒ½å·²ç¦»å¼€æ¸¸æˆ');
                if (joinBtn) joinBtn.disabled = false;
            });

            hostConnection.on('error', (err) => {
                clearTimeout(connectionTimeout);
                console.error('Connection error:', err);

                let errorMsg = 'è¿æ¥é”™è¯¯ï¼š';
                if (err.type === 'peer-unavailable') {
                    errorMsg += 'æˆ¿ä¸»ä¸åœ¨çº¿æˆ–æˆ¿é—´å·²å…³é—­';
                } else if (err.type === 'network') {
                    errorMsg += 'ç½‘ç»œè¿æ¥å¤±è´¥';
                } else if (err.type === 'ssl-unavailable') {
                    errorMsg += 'SSLè¿æ¥ä¸å¯ç”¨';
                } else if (err.type === 'server-error') {
                    errorMsg += 'PeerJSæœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•';
                } else {
                    errorMsg += err.type || 'æœªçŸ¥é”™è¯¯';
                }

                showMessage(errorMsg);
                updateConnectionStatus('error', errorMsg);
                if (joinBtn) joinBtn.disabled = false;
            });
        }

        function showWaitingRoom() {
            document.getElementById('lobby-panel').classList.add('hidden');
            document.getElementById('waiting-room').classList.remove('hidden');

            document.getElementById('display-room-code').textContent = roomId;

            // ç”Ÿæˆåˆ†äº«é“¾æ¥
            const shareUrl = `${window.location.origin}${window.location.pathname}?room=${roomId}&host=${myPeerId}`;
            document.getElementById('share-link').value = shareUrl;

            if (isHost) {
                document.getElementById('host-controls').classList.remove('hidden');

                // æ·»åŠ è¿æ¥çŠ¶æ€æ£€æŸ¥
                const connectionInfo = document.createElement('div');
                connectionInfo.id = 'connection-info';
                connectionInfo.style.cssText = 'margin-top: 15px; padding: 10px; background: rgba(46,204,113,0.1); border-radius: 8px; font-size: 0.85em;';
                connectionInfo.innerHTML = `
                    <p style="color: #2ecc71;">âœ… PeerJSå·²è¿æ¥</p>
                    <p style="color: #bdc3c7;">æˆ¿ä¸»ID: ${myPeerId ? myPeerId.substring(0, 12) + '...' : 'æœªè¿æ¥'}</p>
                `;

                // é¿å…é‡å¤æ·»åŠ 
                const existingInfo = document.getElementById('connection-info');
                if (existingInfo) {
                    existingInfo.replaceWith(connectionInfo);
                } else {
                    document.getElementById('players-list').after(connectionInfo);
                }

                // å®šæœŸæ£€æŸ¥è¿æ¥çŠ¶æ€
                setInterval(() => {
                    if (peer && peer.destroyed) {
                        showMessage('PeerJSè¿æ¥å·²æ–­å¼€ï¼Œè¯·åˆ·æ–°é¡µé¢ï¼');
                    }
                }, 5000);
            } else {
                document.getElementById('guest-message').classList.remove('hidden');

                // è·å–URLå‚æ•°æ˜¾ç¤ºæˆ¿ä¸»ID
                const urlParams = new URLSearchParams(window.location.search);
                const hostId = urlParams.get('host');

                // æ˜¾ç¤ºè¿æ¥çŠ¶æ€
                const connectionInfo = document.createElement('div');
                connectionInfo.id = 'guest-connection-info';
                connectionInfo.style.cssText = 'margin-top: 15px; padding: 10px; background: rgba(241,196,15,0.1); border-radius: 8px; font-size: 0.85em;';
                connectionInfo.innerHTML = `
                    <p style="color: #f1c40f;">â³ æ­£åœ¨è¿æ¥åˆ°æˆ¿ä¸»...</p>
                    <p style="color: #bdc3c7;">æˆ¿ä¸»ID: ${hostId ? hostId.substring(0, 12) + '...' : 'æœªçŸ¥'}</p>
                `;

                const existingInfo = document.getElementById('guest-connection-info');
                if (existingInfo) {
                    existingInfo.replaceWith(connectionInfo);
                } else {
                    document.getElementById('players-list').after(connectionInfo);
                }
            }

            updatePlayersList();
        }

        function updatePlayersList() {
            const listDiv = document.getElementById('players-list');
            listDiv.innerHTML = '';

            gameState.players.forEach((player, index) => {
                const item = document.createElement('div');
                item.className = 'player-item';
                const isLocal = player.isLocal;
                item.innerHTML = `
                    <span class="player-name ${isLocal ? 'is-host' : ''}">${player.name}</span>
                    <span class="player-status">${isLocal ? '(ä½ )' : 'å·²è¿æ¥'}</span>
                `;
                listDiv.appendChild(item);
            });

            // æˆ¿ä¸»æ˜¾ç¤ºè¿æ¥æç¤ºä¿¡æ¯
            if (isHost) {
                const canStart = gameState.players.length >= 2;
                document.getElementById('start-online-btn').disabled = !canStart;

                // æ·»åŠ æç¤ºä¿¡æ¯
                const tipDiv = document.createElement('div');
                tipDiv.style.cssText = 'margin-top: 20px; padding: 15px; background: rgba(255,215,0,0.1); border-radius: 10px; font-size: 0.9em; color: #ffd700;';
                tipDiv.innerHTML = `
                    <p><strong>ğŸ’¡ æç¤ºï¼š</strong></p>
                    <p>1. åˆ†äº«ä¸Šæ–¹é“¾æ¥ç»™æœ‹å‹å³å¯åŠ å…¥æˆ¿é—´</p>
                    <p>2. è‡³å°‘éœ€è¦2åç©å®¶æ‰èƒ½å¼€å§‹æ¸¸æˆ</p>
                    <p>3. ç¡®ä¿ä¿æŒæ­¤é¡µé¢æ‰“å¼€çŠ¶æ€</p>
                    <p>4. ä½ çš„PeerID: ${myPeerId ? myPeerId.substring(0, 8) + '...' : 'æœªè¿æ¥'}</p>
                `;
                listDiv.appendChild(tipDiv);
            } else {
                // ç©å®¶æ˜¾ç¤ºç­‰å¾…æç¤º
                const tipDiv = document.createElement('div');
                tipDiv.style.cssText = 'margin-top: 20px; padding: 15px; background: rgba(241,196,15,0.1); border-radius: 10px; font-size: 0.9em; color: #f1c40f;';
                tipDiv.innerHTML = `
                    <p><strong>â³ ç­‰å¾…æˆ¿ä¸»å¼€å§‹æ¸¸æˆ...</strong></p>
                    <p>æˆ¿é—´è¿æ¥çŠ¶æ€: ${hostConnection && hostConnection.open ? 'âœ… å·²è¿æ¥' : 'âŒ æœªè¿æ¥'}</p>
                `;
                listDiv.appendChild(tipDiv);
            }
        }

        // ==================== æˆ¿ä¸»æ¶ˆæ¯å¤„ç† ====================
        function handlePlayerConnection(conn) {
            playerConnections.push(conn);
            console.log('Player connected:', conn.peer);

            conn.on('data', (data) => {
                handlePlayerMessage(data, conn);
            });

            conn.on('close', () => {
                // ç©å®¶æ–­å¼€è¿æ¥
                const index = playerConnections.indexOf(conn);
                if (index > -1) {
                    playerConnections.splice(index, 1);
                    // ç§»é™¤ç©å®¶
                    const playerIndex = gameState.players.findIndex(p => p.connectionId === conn.peer);
                    if (playerIndex > -1) {
                        const player = gameState.players[playerIndex];
                        gameState.players.splice(playerIndex, 1);
                        // é‡æ–°åˆ†é…ID
                        gameState.players.forEach((p, i) => p.id = i);
                        // å¹¿æ’­ç©å®¶ç¦»å¼€
                        broadcastToPlayers({ type: MESSAGE_TYPES.PLAYER_LEFT, playerIndex });
                        updatePlayersList();
                    }
                }
            });

            conn.on('error', (err) => {
                console.error('Player connection error:', err);
            });
        }

        function handlePlayerMessage(data, conn) {
            console.log('Received from player:', data);

            switch (data.type) {
                case MESSAGE_TYPES.JOIN:
                    // æ–°ç©å®¶åŠ å…¥
                    const newPlayer = new Player(
                        gameState.players.length,
                        data.playerName,
                        false,
                        true
                    );
                    newPlayer.connectionId = conn.peer;
                    newPlayer.conn = conn;
                    gameState.players.push(newPlayer);

                    // å‘é€æ¬¢è¿æ¶ˆæ¯ç»™æ–°ç©å®¶
                    conn.send({
                        type: MESSAGE_TYPES.WELCOME,
                        players: gameState.players.map(p => ({
                            id: p.id,
                            name: p.name,
                            chips: p.chips
                        })),
                        playerIndex: newPlayer.id
                    });

                    // å¹¿æ’­æ–°ç©å®¶åŠ å…¥
                    broadcastToPlayers({
                        type: MESSAGE_TYPES.PLAYER_JOINED,
                        player: { id: newPlayer.id, name: newPlayer.name }
                    }, conn);

                    updatePlayersList();
                    break;

                case MESSAGE_TYPES.ACTION:
                    // ç©å®¶åŠ¨ä½œ
                    executeRemoteAction(data.action, data.playerIndex);
                    break;

                case MESSAGE_TYPES.NEW_GAME_REQUEST:
                    // ç©å®¶è¯·æ±‚å¼€å§‹æ–°æ¸¸æˆ
                    if (gameState.phase === 'showdown') {
                        startNewGame();
                    }
                    break;
            }
        }

        function broadcastToPlayers(message, excludeConn = null) {
            playerConnections.forEach(conn => {
                if (conn !== excludeConn && conn.open) {
                    conn.send(message);
                }
            });
        }

        // ==================== ç©å®¶æ¶ˆæ¯å¤„ç†ï¼ˆéæˆ¿ä¸»ï¼‰ ====================
        function handleHostMessage(data) {
            console.log('Received from host:', data);

            switch (data.type) {
                case MESSAGE_TYPES.WELCOME:
                    gameState.players = data.players.map((p, i) => {
                        const player = new Player(i, p.name, false, p.id === data.playerIndex);
                        player.chips = p.chips;
                        return player;
                    });
                    localPlayerIndex = data.playerIndex;
                    gameState.players[localPlayerIndex].isLocal = true;
                    showWaitingRoom();
                    break;

                case MESSAGE_TYPES.PLAYER_JOINED:
                    const newPlayer = new Player(data.player.id, data.player.name, false, false);
                    gameState.players.push(newPlayer);
                    updatePlayersList();
                    break;

                case MESSAGE_TYPES.PLAYER_LEFT:
                    if (data.playerIndex < gameState.players.length) {
                        gameState.players.splice(data.playerIndex, 1);
                        gameState.players.forEach((p, i) => p.id = i);
                        if (localPlayerIndex > data.playerIndex) {
                            localPlayerIndex--;
                        }
                        updatePlayersList();
                    }
                    break;

                case MESSAGE_TYPES.GAME_START:
                    startGame();
                    break;

                case MESSAGE_TYPES.STATE_UPDATE:
                    // æ›´æ–°æ¸¸æˆçŠ¶æ€
                    updateGameStateFromHost(data);
                    break;

                case MESSAGE_TYPES.NEW_GAME:
                    startNewGame();
                    break;
            }
        }

        function updateGameStateFromHost(data) {
            const state = data.gameState;

            // æ›´æ–°å…¬å…±çŠ¶æ€
            gameState.phase = state.phase;
            gameState.pot = state.pot;
            gameState.currentBet = state.currentBet;
            gameState.currentPlayerIndex = state.currentPlayerIndex;
            gameState.dealerIndex = state.dealerIndex;
            gameState.communityCards = state.communityCards;

            // æ›´æ–°ç©å®¶çŠ¶æ€
            state.players.forEach((p, i) => {
                if (gameState.players[i]) {
                    gameState.players[i].chips = p.chips;
                    gameState.players[i].currentBet = p.currentBet;
                    gameState.players[i].folded = p.folded;
                    gameState.players[i].allIn = p.allIn;
                    gameState.players[i].lastAction = p.lastAction;

                    // åªæ›´æ–°è‡ªå·±çš„ç‰Œ
                    if (i === localPlayerIndex && p.cards) {
                        gameState.players[i].cards = p.cards;
                    }
                }
            });

            // æ‘Šç‰Œæ—¶æ˜¾ç¤ºæ‰€æœ‰ç‰Œ
            if (state.phase === 'showdown' && state.showdownCards) {
                state.showdownCards.forEach((cards, i) => {
                    if (gameState.players[i]) {
                        gameState.players[i].cards = cards;
                    }
                });
            }

            // èƒœè´Ÿåˆ¤å®š
            if (state.phase === 'showdown' && state.winners) {
                setTimeout(() => {
                    const winnerNames = state.winners.map(w => gameState.players[w]?.name || 'æœªçŸ¥').join(' & ');
                    showMessage(`${winnerNames} è·èƒœï¼${state.handName || ''}`);
                }, 500);
            }

            updateDisplay();

            // è½®åˆ°æœ¬åœ°ç©å®¶
            if (state.currentPlayerIndex === localPlayerIndex && state.phase !== 'showdown') {
                enableControls();
                showMessage('è½®åˆ°ä½ äº†ï¼');
            } else {
                disableControls();
            }
        }

        // ==================== åœ¨çº¿æ¸¸æˆ ====================
        function startOnlineGame() {
            if (!isHost) return;

            // é€šçŸ¥æ‰€æœ‰ç©å®¶å¼€å§‹æ¸¸æˆ
            broadcastToPlayers({ type: MESSAGE_TYPES.GAME_START });
            startGame();
        }

        function requestNewGame() {
            if (gameMode === 'online') {
                if (isHost) {
                    startNewGame();
                } else {
                    hostConnection.send({ type: MESSAGE_TYPES.NEW_GAME_REQUEST });
                }
            } else {
                startNewGame();
            }
        }

        // ==================== å•æœºæ¸¸æˆ ====================
        function updatePlayerCount() {
            const count = parseInt(document.getElementById('player-count').value);
            document.getElementById('player-count-display').textContent = count;
            generatePlayerConfig(count);
        }

        function generatePlayerConfig(count) {
            const container = document.getElementById('player-config-list');
            container.innerHTML = '';

            for (let i = 0; i < count; i++) {
                const isHuman = i === 0;
                const div = document.createElement('div');
                div.className = 'player-config-item';
                div.innerHTML = `
                    <label>
                        <input type="checkbox" ${isHuman ? 'checked' : ''} data-player="${i}">
                        ç©å®¶ ${i + 1} ${isHuman ? '(ä½ )' : ''}
                    </label>
                `;
                container.appendChild(div);
            }
        }

        function startLocalGame() {
            gameMode = 'local';
            isHost = true;

            const count = parseInt(document.getElementById('player-count').value);
            gameConfig.totalPlayers = count;
            gameConfig.humanPlayers = [];

            document.querySelectorAll('#player-config-list input[type="checkbox"]').forEach(cb => {
                if (cb.checked) {
                    gameConfig.humanPlayers.push(parseInt(cb.dataset.player));
                }
            });

            // åˆå§‹åŒ–ç©å®¶
            gameState.players = [];
            for (let i = 0; i < count; i++) {
                const isHuman = gameConfig.humanPlayers.includes(i);
                const personality = isHuman ? null : AI_PERSONALITIES[i % AI_PERSONALITIES.length];
                const player = new Player(i, isHuman ? `ç©å®¶${i + 1}` : `${personality.name}${i + 1}`, true, isHuman);
                player.personality = personality;
                gameState.players.push(player);
            }

            localPlayerIndex = gameConfig.humanPlayers[0] || 0;

            document.getElementById('setup-panel').classList.add('hidden');
            document.getElementById('game-area').classList.remove('display');
            document.getElementById('game-area').style.display = 'block';

            createPlayerSeats();
            startGame();
        }

        // ==================== æ¸¸æˆå¼€å§‹ ====================
        function startGame() {
            document.getElementById('waiting-room').classList.add('hidden');
            document.getElementById('game-area').style.display = 'block';

            createPlayerSeats();
            startNewGame();
        }

        function startNewGame() {
            // é‡ç½®çŠ¶æ€
            gameState.round++;
            gameState.phase = 'preflop';
            gameState.pot = 0;
            gameState.currentBet = 0;
            gameState.minRaise = gameConfig.bigBlind;
            gameState.lastRaiser = -1;
            gameState.communityCards = [];
            gameState.deck = createDeck();

            // ç§»åŠ¨åº„å®¶ä½ç½®
            gameState.dealerIndex = (gameState.dealerIndex + 1) % gameState.players.length;

            // é‡ç½®ç©å®¶
            gameState.players.forEach(p => {
                if (p.chips <= 0) {
                    p.chips = gameConfig.startingChips;
                }
                p.reset();
            });

            // å‘ç‰Œ
            gameState.players.forEach(p => {
                p.cards = [gameState.deck.pop(), gameState.deck.pop()];
            });

            // ä¸‹ç›²æ³¨
            postBlinds();

            // è®¾ç½®ç¬¬ä¸€ä¸ªè¡ŒåŠ¨ç©å®¶
            const sbIndex = (gameState.dealerIndex + 1) % gameState.players.length;
            const bbIndex = (gameState.dealerIndex + 2) % gameState.players.length;
            gameState.currentPlayerIndex = (bbIndex + 1) % gameState.players.length;
            gameState.lastRaiser = gameState.currentPlayerIndex;

            updateDisplay();
            showMessage('ç¬¬ ' + gameState.round + ' å›åˆå¼€å§‹ï¼');

            // åœ¨çº¿æ¨¡å¼ï¼šå¹¿æ’­çŠ¶æ€
            if (gameMode === 'online' && isHost) {
                broadcastGameState();
            }

            // å¼€å§‹ç¬¬ä¸€ä¸ªç©å®¶çš„å›åˆ
            setTimeout(() => processTurn(), 1000);
        }

        function postBlinds() {
            const sbIndex = (gameState.dealerIndex + 1) % gameState.players.length;
            const bbIndex = (gameState.dealerIndex + 2) % gameState.players.length;

            placeBet(sbIndex, gameConfig.smallBlind);
            placeBet(bbIndex, gameConfig.bigBlind);

            gameState.players[sbIndex].lastAction = 'å°ç›²';
            gameState.players[bbIndex].lastAction = 'å¤§ç›²';
        }

        function placeBet(playerIndex, amount) {
            const player = gameState.players[playerIndex];
            const actualBet = Math.min(amount, player.chips);

            player.chips -= actualBet;
            player.currentBet += actualBet;
            gameState.pot += actualBet;

            if (actualBet > gameState.currentBet) {
                gameState.currentBet = actualBet;
            }

            if (player.chips === 0) {
                player.allIn = true;
            }

            updateDisplay();
        }

        // ==================== å›åˆå¤„ç† ====================
        function processTurn() {
            const activePlayers = gameState.players.filter(p => !p.folded);
            if (activePlayers.length === 1) {
                endRound(activePlayers[0]);
                return;
            }

            if (isRoundComplete()) {
                nextPhase();
                return;
            }

            const player = gameState.players[gameState.currentPlayerIndex];

            if (player.allIn || player.folded) {
                nextPlayer();
                return;
            }

            updateDisplay();

            const isMyTurn = player.isLocal || (gameMode === 'local' && player.isHuman);

            if (isMyTurn) {
                enableControls();
                showMessage('è½®åˆ°ä½ äº†ï¼');
            } else {
                disableControls();
                setTimeout(() => aiTurn(player), 1000);
            }
        }

        function aiTurn(player) {
            const callAmount = gameState.currentBet - player.currentBet;
            const handStrength = evaluateHandStrength(player);
            const personality = player.personality || AI_PERSONALITIES[1];
            const random = Math.random();

            let action;

            if (callAmount === 0) {
                if (handStrength > 0.6 && random < personality.aggression) {
                    action = 'raise';
                } else {
                    action = 'check';
                }
            } else {
                if (handStrength < personality.foldThreshold && random > personality.bluffChance) {
                    action = 'fold';
                } else if (handStrength > 0.7 && random < personality.aggression) {
                    action = 'raise';
                } else if (callAmount > player.chips * 0.5 && handStrength < 0.5) {
                    action = random < 0.5 ? 'fold' : 'call';
                } else {
                    action = 'call';
                }
            }

            executeAction(player, action);
        }

        function executeAction(player, action) {
            const callAmount = gameState.currentBet - player.currentBet;

            switch (action) {
                case 'fold':
                    player.folded = true;
                    player.lastAction = 'å¼ƒç‰Œ';
                    showMessage(`${player.name} å¼ƒç‰Œ`);
                    break;

                case 'check':
                    player.lastAction = 'è¿‡ç‰Œ';
                    showMessage(`${player.name} è¿‡ç‰Œ`);
                    break;

                case 'call':
                    placeBet(player.id, callAmount);
                    player.lastAction = 'è·Ÿæ³¨';
                    showMessage(`${player.name} è·Ÿæ³¨ ${callAmount}`);
                    break;

                case 'raise':
                    const raiseAmount = callAmount + gameConfig.bigBlind * 2;
                    if (raiseAmount <= player.chips) {
                        placeBet(player.id, raiseAmount);
                        player.lastAction = 'åŠ æ³¨';
                        gameState.lastRaiser = player.id;
                        showMessage(`${player.name} åŠ æ³¨åˆ° ${player.currentBet}`);
                    } else {
                        placeBet(player.id, player.chips);
                        player.lastAction = 'å…¨æŠ¼';
                        showMessage(`${player.name} å…¨æŠ¼`);
                    }
                    break;

                case 'allin':
                    placeBet(player.id, player.chips);
                    player.lastAction = 'å…¨æŠ¼';
                    showMessage(`${player.name} å…¨æŠ¼`);
                    break;
            }

            updateDisplay();

            // åœ¨çº¿æ¨¡å¼ï¼šå‘é€åŠ¨ä½œç»™æˆ¿ä¸»æˆ–å¹¿æ’­
            if (gameMode === 'online') {
                if (isHost) {
                    broadcastGameState();
                } else {
                    hostConnection.send({
                        type: MESSAGE_TYPES.ACTION,
                        action: action,
                        playerIndex: player.id
                    });
                }
            }

            setTimeout(() => nextPlayer(), 500);
        }

        function executeRemoteAction(action, playerIndex) {
            const player = gameState.players[playerIndex];
            if (!player) return;

            executeAction(player, action);
        }

        function playerAction(action) {
            disableControls();
            const player = gameState.players[gameState.currentPlayerIndex];

            if (gameMode === 'online' && !isHost) {
                // å‘é€åŠ¨ä½œç»™æˆ¿ä¸»
                hostConnection.send({
                    type: MESSAGE_TYPES.ACTION,
                    action: action,
                    playerIndex: player.id
                });

                // æœ¬åœ°é¢„è§ˆ
                player.lastAction = getActionName(action);
                updateDisplay();
            } else {
                executeAction(player, action);
            }
        }

        function getActionName(action) {
            const names = {
                'fold': 'å¼ƒç‰Œ',
                'check': 'è¿‡ç‰Œ',
                'call': 'è·Ÿæ³¨',
                'raise': 'åŠ æ³¨',
                'allin': 'å…¨æŠ¼'
            };
            return names[action] || action;
        }

        function nextPlayer() {
            let nextIndex = gameState.currentPlayerIndex;
            let loopCount = 0;

            do {
                nextIndex = (nextIndex + 1) % gameState.players.length;
                loopCount++;
            } while (
                loopCount <= gameState.players.length &&
                (gameState.players[nextIndex].folded || gameState.players[nextIndex].allIn)
            );

            gameState.currentPlayerIndex = nextIndex;
            processTurn();
        }

        function isRoundComplete() {
            const activePlayers = gameState.players.filter(p => !p.folded && !p.allIn);
            if (activePlayers.length <= 1) return true;

            const firstBet = activePlayers[0].currentBet;
            const allMatched = activePlayers.every(p => p.currentBet === firstBet);
            const raiserActed = gameState.currentPlayerIndex === gameState.lastRaiser;

            return allMatched && raiserActed && gameState.currentBet > 0;
        }

        // ==================== é˜¶æ®µæ¨è¿› ====================
        function nextPhase() {
            gameState.players.forEach(p => p.currentBet = 0);
            gameState.currentBet = 0;
            gameState.lastRaiser = (gameState.dealerIndex + 1) % gameState.players.length;
            gameState.currentPlayerIndex = gameState.lastRaiser;

            switch (gameState.phase) {
                case 'preflop':
                    gameState.phase = 'flop';
                    gameState.communityCards.push(
                        gameState.deck.pop(),
                        gameState.deck.pop(),
                        gameState.deck.pop()
                    );
                    showMessage('ç¿»ç‰Œåœˆï¼');
                    break;

                case 'flop':
                    gameState.phase = 'turn';
                    gameState.communityCards.push(gameState.deck.pop());
                    showMessage('è½¬ç‰Œåœˆï¼');
                    break;

                case 'turn':
                    gameState.phase = 'river';
                    gameState.communityCards.push(gameState.deck.pop());
                    showMessage('æ²³ç‰Œåœˆï¼');
                    break;

                case 'river':
                    showdown();
                    return;
            }

            updateDisplay();

            if (gameMode === 'online' && isHost) {
                broadcastGameState();
            }

            setTimeout(() => processTurn(), 1000);
        }

        // ==================== æ‘Šç‰Œ ====================
        function showdown() {
            gameState.phase = 'showdown';
            const activePlayers = gameState.players.filter(p => !p.folded);

            if (activePlayers.length === 1) {
                endRound(activePlayers[0]);
                return;
            }

            let bestHand = null;
            let winners = [];

            for (const player of activePlayers) {
                const hand = evaluateHand([...player.cards, ...gameState.communityCards]);
                player.hand = hand;

                if (!bestHand || compareHands(hand, bestHand) > 0) {
                    bestHand = hand;
                    winners = [player];
                } else if (compareHands(hand, bestHand) === 0) {
                    winners.push(player);
                }
            }

            updateDisplay(true);

            const winAmount = Math.floor(gameState.pot / winners.length);
            winners.forEach(w => w.chips += winAmount);

            let resultText = winners.length === 1
                ? `${winners[0].name} è·èƒœï¼${winners[0].hand.name}`
                : `å¹³å±€ï¼${winners.map(w => w.name).join(' & ')} å„èµ¢ ${winAmount}`;

            showMessage(resultText);

            // åœ¨çº¿æ¨¡å¼ï¼šå¹¿æ’­ç»“æœ
            if (gameMode === 'online' && isHost) {
                broadcastGameState();
            }

            disableControls();
        }

        function endRound(winner) {
            winner.chips += gameState.pot;
            showMessage(`${winner.name} èµ¢å¾—åº•æ±  ${gameState.pot}ï¼`);
            gameState.phase = 'showdown';
            updateDisplay(true);
            disableControls();

            if (gameMode === 'online' && isHost) {
                broadcastGameState();
            }
        }

        // ==================== çŠ¶æ€å¹¿æ’­ï¼ˆæˆ¿ä¸»ï¼‰ ====================
        function broadcastGameState() {
            if (!isHost || gameMode !== 'online') return;

            const showdownCards = gameState.phase === 'showdown' ?
                gameState.players.map(p => p.cards) : null;

            const winners = gameState.phase === 'showdown' ?
                gameState.players
                    .map((p, i) => ({ player: p, index: i }))
                    .filter(({ player }) => !player.folded)
                    .sort((a, b) => compareHands(b.player.hand, a.player.hand))
                    .slice(0, 1)
                    .map(w => w.index) : null;

            const stateMessage = {
                type: MESSAGE_TYPES.STATE_UPDATE,
                gameState: {
                    phase: gameState.phase,
                    pot: gameState.pot,
                    currentBet: gameState.currentBet,
                    currentPlayerIndex: gameState.currentPlayerIndex,
                    dealerIndex: gameState.dealerIndex,
                    communityCards: gameState.communityCards,
                    showdownCards: showdownCards,
                    winners: winners,
                    handName: winners !== null ?
                        gameState.players[winners[0]]?.hand?.name : null,
                    players: gameState.players.map((p, i) => ({
                        id: p.id,
                        name: p.name,
                        chips: p.chips,
                        currentBet: p.currentBet,
                        folded: p.folded,
                        allIn: p.allIn,
                        lastAction: p.lastAction,
                        cards: i === localPlayerIndex ? p.cards : []
                    }))
                }
            };

            broadcastToPlayers(stateMessage);
        }

        // ==================== ç‰Œå‹è¯„ä¼° ====================
        function evaluateHand(cards) {
            const values = cards.map(c => c.value).sort((a, b) => b - a);
            const suits = cards.map(c => c.suit);

            const valueCounts = {};
            values.forEach(v => valueCounts[v] = (valueCounts[v] || 0) + 1);
            const counts = Object.values(valueCounts).sort((a, b) => b - a);

            const suitCounts = {};
            suits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1);
            const isFlush = Object.values(suitCounts).some(c => c >= 5);

            const uniqueValues = [...new Set(values)].sort((a, b) => b - a);
            const isStraight = checkStraight(uniqueValues);

            if (isFlush && isStraight) return { rank: 9, name: 'åŒèŠ±é¡º', values };
            if (counts[0] === 4) return { rank: 8, name: 'å››æ¡', values };
            if (counts[0] === 3 && counts[1] >= 2) return { rank: 7, name: 'è‘«èŠ¦', values };
            if (isFlush) return { rank: 6, name: 'åŒèŠ±', values };
            if (isStraight) return { rank: 5, name: 'é¡ºå­', values };
            if (counts[0] === 3) return { rank: 4, name: 'ä¸‰æ¡', values };
            if (counts[0] === 2 && counts[1] === 2) return { rank: 3, name: 'ä¸¤å¯¹', values };
            if (counts[0] === 2) return { rank: 2, name: 'ä¸€å¯¹', values };
            return { rank: 1, name: 'é«˜ç‰Œ', values };
        }

        function evaluateHandStrength(player) {
            if (gameState.communityCards.length === 0) {
                const c1 = player.cards[0];
                const c2 = player.cards[1];
                const isPair = c1.value === c2.value;
                const isSuited = c1.suit === c2.suit;
                const highCard = Math.max(c1.value, c2.value);

                let strength = highCard / 14 * 0.3;
                if (isPair) strength += 0.3;
                if (isSuited) strength += 0.1;
                if (Math.abs(c1.value - c2.value) <= 4) strength += 0.1;

                return Math.min(strength, 1);
            } else {
                const hand = evaluateHand([...player.cards, ...gameState.communityCards]);
                return hand.rank / 9;
            }
        }

        function checkStraight(values) {
            for (let i = 0; i <= values.length - 5; i++) {
                if (values[i] - values[i + 4] === 4) return true;
            }
            if (values.includes(14) && values.includes(2) && values.includes(3) && values.includes(4) && values.includes(5)) {
                return true;
            }
            return false;
        }

        function compareHands(hand1, hand2) {
            if (hand1.rank !== hand2.rank) {
                return hand1.rank - hand2.rank;
            }
            for (let i = 0; i < Math.min(hand1.values.length, hand2.values.length); i++) {
                if (hand1.values[i] !== hand2.values[i]) {
                    return hand1.values[i] - hand2.values[i];
                }
            }
            return 0;
        }

        // ==================== å·¥å…·å‡½æ•° ====================
        function createDeck() {
            const deck = [];
            for (const suit of SUITS) {
                for (const rank of RANKS) {
                    deck.push({ suit, rank, value: RANK_VALUES[rank] });
                }
            }
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        function createCardElement(card, faceDown = false) {
            const div = document.createElement('div');
            div.className = 'card';

            if (faceDown) {
                div.classList.add('card-back');
                return div;
            }

            const isRed = card.suit === 'â™¥' || card.suit === 'â™¦';
            div.classList.add(isRed ? 'red' : 'black');

            div.innerHTML = `
                <span class="card-rank">${card.rank}</span>
                <span class="card-suit">${card.suit}</span>
            `;

            return div;
        }

        // ==================== æ˜¾ç¤ºæ›´æ–° ====================
        function createPlayerSeats() {
            const container = document.getElementById('player-seats');
            container.innerHTML = '';

            const count = gameState.players.length;
            const radius = 280;

            for (let i = 0; i < count; i++) {
                const angle = (i * 360 / count - 90) * Math.PI / 180;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                const seat = document.createElement('div');
                seat.className = 'player-seat';
                seat.id = `player-seat-${i}`;
                seat.style.left = `calc(50% + ${x}px - 90px)`;
                seat.style.top = `calc(50% + ${y}px - 60px)`;
                seat.innerHTML = `
                    <div class="player-info">
                        <span class="player-name">${gameState.players[i].name}</span>
                        <span class="player-chips">${gameState.players[i].chips}</span>
                    </div>
                    <div class="player-cards" id="player-cards-${i}"></div>
                    <div class="player-bet" id="player-bet-${i}"></div>
                    <div class="player-action" id="player-action-${i}"></div>
                `;
                container.appendChild(seat);
            }
        }

        function updateDisplay(showAllCards = false) {
            document.getElementById('round-num').textContent = gameState.round;
            document.getElementById('small-blind').textContent = gameConfig.smallBlind;
            document.getElementById('big-blind').textContent = gameConfig.bigBlind;
            document.getElementById('pot').textContent = gameState.pot;

            const phaseNames = {
                'idle': 'ç­‰å¾…å¼€å§‹',
                'preflop': 'ç¿»ç‰Œå‰',
                'flop': 'ç¿»ç‰Œåœˆ',
                'turn': 'è½¬ç‰Œåœˆ',
                'river': 'æ²³ç‰Œåœˆ',
                'showdown': 'æ‘Šç‰Œ'
            };
            document.getElementById('phase-display').textContent = phaseNames[gameState.phase];

            // æ›´æ–°å…¬å…±ç‰Œ
            const communityDiv = document.getElementById('community-cards');
            communityDiv.innerHTML = '';
            for (let i = 0; i < 5; i++) {
                if (i < gameState.communityCards.length) {
                    communityDiv.appendChild(createCardElement(gameState.communityCards[i]));
                } else {
                    const backCard = document.createElement('div');
                    backCard.className = 'card card-back';
                    communityDiv.appendChild(backCard);
                }
            }

            // æ›´æ–°ç©å®¶åº§ä½
            gameState.players.forEach((player, index) => {
                const seat = document.getElementById(`player-seat-${index}`);
                if (!seat) return;

                const cardsDiv = document.getElementById(`player-cards-${index}`);
                const betDiv = document.getElementById(`player-bet-${index}`);
                const actionDiv = document.getElementById(`player-action-${index}`);

                seat.classList.toggle('active', index === gameState.currentPlayerIndex && gameState.phase !== 'idle' && gameState.phase !== 'showdown');
                seat.classList.toggle('folded', player.folded);
                seat.classList.toggle('dealer', index === gameState.dealerIndex);

                seat.querySelector('.player-chips').textContent = player.chips;

                cardsDiv.innerHTML = '';
                if (player.cards.length > 0) {
                    const showCards = player.isLocal || showAllCards || gameState.phase === 'showdown';
                    player.cards.forEach(card => {
                        cardsDiv.appendChild(createCardElement(card, !showCards));
                    });
                }

                betDiv.textContent = player.currentBet > 0 ? `ä¸‹æ³¨: ${player.currentBet}` : '';
                if (player.allIn) betDiv.textContent = 'å…¨æŠ¼ï¼';

                actionDiv.textContent = player.lastAction;
            });

            // æ›´æ–°è·Ÿæ³¨é‡‘é¢
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            if (currentPlayer && gameState.phase !== 'idle' && gameState.phase !== 'showdown') {
                const callAmount = gameState.currentBet - currentPlayer.currentBet;
                document.getElementById('call-amount').textContent = callAmount > 0 ? callAmount : '';
            }

            updateHandStrength();
        }

        function updateHandStrength() {
            const myPlayer = gameState.players[localPlayerIndex];
            if (!myPlayer || myPlayer.cards.length === 0) {
                document.getElementById('hand-strength').textContent = '';
                return;
            }

            const hand = evaluateHand([...myPlayer.cards, ...gameState.communityCards]);
            document.getElementById('hand-strength').textContent = `å½“å‰ç‰Œå‹: ${hand.name}`;
        }

        function showMessage(msg) {
            document.getElementById('message').textContent = msg;
        }

        function enableControls() {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const callAmount = gameState.currentBet - currentPlayer.currentBet;

            document.getElementById('btn-fold').disabled = false;
            document.getElementById('btn-check').disabled = callAmount > 0;
            document.getElementById('btn-call').disabled = callAmount === 0 || callAmount > currentPlayer.chips;
            document.getElementById('btn-raise').disabled = currentPlayer.chips <= callAmount;
            document.getElementById('btn-allin').disabled = false;
            document.getElementById('btn-new-game').disabled = gameState.phase !== 'showdown';
        }

        function disableControls() {
            document.getElementById('btn-fold').disabled = true;
            document.getElementById('btn-check').disabled = true;
            document.getElementById('btn-call').disabled = true;
            document.getElementById('btn-raise').disabled = true;
            document.getElementById('btn-allin').disabled = true;
            document.getElementById('btn-new-game').disabled = gameState.phase !== 'showdown';
        }

        function exitGame() {
            if (confirm('ç¡®å®šè¦é€€å‡ºæ¸¸æˆå—ï¼Ÿ')) {
                location.reload();
            }
        }

        // ==================== URLå‚æ•°è§£æ ====================
        function parseUrlParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const room = urlParams.get('room');
            const host = urlParams.get('host');

            if (room && host) {
                // è‡ªåŠ¨è¿›å…¥åŠ å…¥æˆ¿é—´æµç¨‹
                selectMode('online');
                document.getElementById('join-player-name').value = '';
                document.getElementById('room-code-input').value = room;
                showLobbyTab('join');
            }
        }

        // ==================== åˆå§‹åŒ– ====================
        parseUrlParams();
    </script>
</body>
</html>
