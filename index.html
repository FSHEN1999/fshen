<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šäººå¾·å·æ‰‘å…‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: linear-gradient(90deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* é…ç½®é¢æ¿ */
        .setup-panel {
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            margin: 50px auto;
            text-align: center;
        }

        .setup-panel h2 {
            color: #ffd700;
            margin-bottom: 30px;
            font-size: 2em;
        }

        .setup-option {
            margin: 20px 0;
        }

        .setup-option label {
            display: block;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .setup-option input[type="range"] {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
        }

        .setup-option input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
        }

        .player-count-display {
            font-size: 2em;
            color: #ffd700;
            font-weight: bold;
        }

        .player-config-list {
            margin: 20px 0;
            text-align: left;
        }

        .player-config-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-config-item label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .player-config-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-left: 10px;
        }

        .btn-start {
            margin-top: 20px;
            padding: 15px 50px;
            font-size: 1.3em;
            font-weight: bold;
            border: none;
            border-radius: 30px;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #1a1a2e;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .btn-start:hover {
            transform: scale(1.05);
        }

        /* æ¸¸æˆç•Œé¢ */
        .game-area {
            display: none;
        }

        .game-info {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        .game-info span {
            margin: 0 20px;
            color: #ffd700;
        }

        /* ç¯å½¢å¸ƒå±€ */
        .poker-table-container {
            position: relative;
            width: 100%;
            height: 600px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .poker-table {
            position: absolute;
            width: 400px;
            height: 400px;
            background: radial-gradient(ellipse at center, #2d5a27 0%, #1e3d1a 100%);
            border-radius: 50%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5), inset 0 0 100px rgba(0,0,0,0.3);
            border: 15px solid #4a2c18;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1;
        }

        .table-center {
            text-align: center;
        }

        .pot-display {
            font-size: 1.8em;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        .community-cards {
            display: flex;
            justify-content: center;
            gap: 10px;
            min-height: 100px;
        }

        .card {
            width: 60px;
            height: 84px;
            background: linear-gradient(145deg, #fff 0%, #f0f0f0 100%);
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            position: relative;
        }

        .card.red {
            color: #e74c3c;
        }

        .card.black {
            color: #2c3e50;
        }

        .card-suit {
            font-size: 24px;
        }

        .card-rank {
            font-size: 20px;
        }

        .card-back {
            background: linear-gradient(135deg, #c0392b 0%, #e74c3c 50%, #c0392b 100%);
            background-size: 15px 15px;
        }

        .card-back::before {
            content: 'ğŸ‚ ';
            font-size: 40px;
            color: #fff;
            opacity: 0.3;
        }

        .phase-display {
            margin-top: 15px;
            font-size: 1.2em;
            color: #fff;
        }

        /* ç©å®¶åº§ä½ */
        .player-seat {
            position: absolute;
            width: 180px;
            background: rgba(0,0,0,0.7);
            border-radius: 15px;
            padding: 15px;
            border: 2px solid rgba(255,255,255,0.2);
            transition: all 0.3s;
            z-index: 2;
        }

        .player-seat.active {
            border-color: #ffd700;
            box-shadow: 0 0 30px rgba(255,215,0,0.5);
            transform: scale(1.1);
        }

        .player-seat.folded {
            opacity: 0.4;
        }

        .player-seat.dealer .player-name::after {
            content: ' ğŸ´';
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .player-name {
            font-size: 1.1em;
            color: #ffd700;
            font-weight: bold;
        }

        .player-chips {
            font-size: 1em;
            color: #fff;
        }

        .player-cards {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-bottom: 8px;
            min-height: 45px;
        }

        .player-cards .card {
            width: 40px;
            height: 56px;
            font-size: 14px;
        }

        .player-cards .card-suit {
            font-size: 18px;
        }

        .player-cards .card-rank {
            font-size: 16px;
        }

        .player-bet {
            text-align: center;
            font-size: 1em;
            color: #2ecc71;
        }

        .player-action {
            text-align: center;
            font-size: 0.9em;
            color: #fff;
            margin-top: 5px;
            min-height: 20px;
        }

        /* æ§åˆ¶æŒ‰é’® */
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .controls button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .btn-fold {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .btn-check {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
        }

        .btn-call {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .btn-raise {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }

        .btn-allin {
            background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
            color: white;
        }

        .controls button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .controls button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        /* æ¶ˆæ¯æ˜¾ç¤º */
        .message-area {
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            min-height: 50px;
            font-size: 1.1em;
        }

        /* æ‰‹ç‰Œå¼ºåº¦æ˜¾ç¤ºï¼ˆä»…å¯¹çœŸäººç©å®¶ï¼‰ */
        .hand-strength {
            text-align: center;
            margin-top: 10px;
            font-size: 1em;
            color: #2ecc71;
        }

        /* å“åº”å¼ */
        @media (max-width: 768px) {
            .poker-table {
                width: 300px;
                height: 300px;
            }

            .player-seat {
                width: 140px;
                padding: 10px;
            }

            .card {
                width: 50px;
                height: 70px;
            }

            .controls button {
                padding: 12px 20px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸƒ å¤šäººå¾·å·æ‰‘å…‹ ğŸƒ</h1>

        <!-- é…ç½®é¢æ¿ -->
        <div class="setup-panel" id="setup-panel">
            <h2>æ¸¸æˆè®¾ç½®</h2>
            <div class="setup-option">
                <label>ç©å®¶æ•°é‡</label>
                <input type="range" id="player-count" min="2" max="10" value="4" oninput="updatePlayerCount()">
                <div class="player-count-display"><span id="player-count-display">4</span> äºº</div>
            </div>
            <div class="player-config-list" id="player-config-list">
                <!-- åŠ¨æ€ç”Ÿæˆ -->
            </div>
            <button class="btn-start" onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
        </div>

        <!-- æ¸¸æˆåŒºåŸŸ -->
        <div class="game-area" id="game-area">
            <div class="game-info">
                <span>å›åˆ: <span id="round-num">1</span></span>
                <span>å°ç›²: <span id="small-blind">10</span></span>
                <span>å¤§ç›²: <span id="big-blind">20</span></span>
                <button onclick="showSetupPanel()" style="padding: 8px 15px; border-radius: 15px; border: none; background: #e74c3c; color: white; cursor: pointer;">è¿”å›è®¾ç½®</button>
            </div>

            <div class="poker-table-container">
                <div class="poker-table">
                    <div class="table-center">
                        <div class="pot-display">åº•æ± : <span id="pot">0</span></div>
                        <div class="community-cards" id="community-cards">
                            <div class="card card-back"></div>
                            <div class="card card-back"></div>
                            <div class="card card-back"></div>
                            <div class="card card-back"></div>
                            <div class="card card-back"></div>
                        </div>
                        <div class="phase-display" id="phase-display">ç­‰å¾…å¼€å§‹</div>
                    </div>
                </div>
                <div id="player-seats">
                    <!-- åŠ¨æ€ç”Ÿæˆç©å®¶åº§ä½ -->
                </div>
            </div>

            <div class="hand-strength" id="hand-strength"></div>

            <div class="message-area" id="message">ç‚¹å‡»"æ–°æ¸¸æˆ"å¼€å§‹</div>

            <div class="controls">
                <button class="btn-fold" onclick="playerAction('fold')" id="btn-fold" disabled>å¼ƒç‰Œ</button>
                <button class="btn-check" onclick="playerAction('check')" id="btn-check" disabled>è¿‡ç‰Œ</button>
                <button class="btn-call" onclick="playerAction('call')" id="btn-call" disabled>è·Ÿæ³¨ <span id="call-amount"></span></button>
                <button class="btn-raise" onclick="playerAction('raise')" id="btn-raise" disabled>åŠ æ³¨ 50</button>
                <button class="btn-allin" onclick="playerAction('allin')" id="btn-allin" disabled>å…¨æŠ¼</button>
                <button class="btn-start" onclick="newGame()" id="btn-new-game" style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);">æ–°æ¸¸æˆ</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== æ•°æ®ç»“æ„ ====================
        const SUITS = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const RANK_VALUES = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14};

        // ç©å®¶ç±»
        class Player {
            constructor(id, name, isHuman = false, chips = 1000) {
                this.id = id;
                this.name = name;
                this.isHuman = isHuman;
                this.chips = chips;
                this.initialChips = chips;
                this.cards = [];
                this.currentBet = 0;
                this.folded = false;
                this.allIn = false;
                this.lastAction = '';
            }

            reset() {
                this.cards = [];
                this.currentBet = 0;
                this.folded = false;
                this.allIn = false;
                this.lastAction = '';
            }
        }

        // AI ä¸ªæ€§
        const AI_PERSONALITIES = [
            { name: 'ä¿å®ˆå‹', aggression: 0.2, bluffChance: 0.05, foldThreshold: 0.3 },
            { name: 'å¹³è¡¡å‹', aggression: 0.5, bluffChance: 0.2, foldThreshold: 0.2 },
            { name: 'æ¿€è¿›å‹', aggression: 0.8, bluffChance: 0.4, foldThreshold: 0.1 }
        ];

        // æ¸¸æˆé…ç½®
        let gameConfig = {
            totalPlayers: 4,
            humanPlayers: [0],
            smallBlind: 10,
            bigBlind: 20,
            startingChips: 1000
        };

        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            phase: 'idle',           // idle, preflop, flop, turn, river, showdown
            round: 0,
            pot: 0,
            currentBet: 0,
            minRaise: 20,
            currentPlayerIndex: 0,
            dealerIndex: 0,
            lastRaiser: -1,
            players: [],
            deck: [],
            communityCards: []
        };

        // ==================== åˆå§‹åŒ– ====================
        function init() {
            updatePlayerCount();
        }

        function updatePlayerCount() {
            const count = parseInt(document.getElementById('player-count').value);
            document.getElementById('player-count-display').textContent = count;
            generatePlayerConfig(count);
        }

        function generatePlayerConfig(count) {
            const container = document.getElementById('player-config-list');
            container.innerHTML = '';

            for (let i = 0; i < count; i++) {
                const isHuman = i === 0;
                const div = document.createElement('div');
                div.className = 'player-config-item';
                div.innerHTML = `
                    <label>
                        <input type="checkbox" ${isHuman ? 'checked' : ''} data-player="${i}">
                        ç©å®¶ ${i + 1} ${isHuman ? '(ä½ )' : ''}
                    </label>
                `;
                container.appendChild(div);
            }
        }

        // ==================== æ¸¸æˆå¼€å§‹ ====================
        function startGame() {
            // è·å–é…ç½®
            const count = parseInt(document.getElementById('player-count').value);
            gameConfig.totalPlayers = count;
            gameConfig.humanPlayers = [];

            document.querySelectorAll('#player-config-list input[type="checkbox"]').forEach(cb => {
                if (cb.checked) {
                    gameConfig.humanPlayers.push(parseInt(cb.dataset.player));
                }
            });

            // åˆå§‹åŒ–ç©å®¶
            gameState.players = [];
            for (let i = 0; i < count; i++) {
                const isHuman = gameConfig.humanPlayers.includes(i);
                const personality = isHuman ? null : AI_PERSONALITIES[i % AI_PERSONALITIES.length];
                const player = new Player(i, isHuman ? `ç©å®¶${i + 1}` : `${personality.name}${i + 1}`, isHuman);
                player.personality = personality;
                gameState.players.push(player);
            }

            // æ˜¾ç¤ºæ¸¸æˆç•Œé¢
            document.getElementById('setup-panel').style.display = 'none';
            document.getElementById('game-area').style.display = 'block';

            // åˆ›å»ºç©å®¶åº§ä½
            createPlayerSeats();

            // å¼€å§‹æ–°æ¸¸æˆ
            newGame();
        }

        function showSetupPanel() {
            document.getElementById('setup-panel').style.display = 'block';
            document.getElementById('game-area').style.display = 'none';
        }

        function createPlayerSeats() {
            const container = document.getElementById('player-seats');
            container.innerHTML = '';

            const count = gameState.players.length;
            const radius = 280; // ç¯å½¢åŠå¾„

            for (let i = 0; i < count; i++) {
                const angle = (i * 360 / count - 90) * Math.PI / 180; // -90åº¦è®©ç¬¬ä¸€ä¸ªç©å®¶åœ¨é¡¶éƒ¨
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                const seat = document.createElement('div');
                seat.className = 'player-seat';
                seat.id = `player-seat-${i}`;
                seat.style.left = `calc(50% + ${x}px - 90px)`;
                seat.style.top = `calc(50% + ${y}px - 60px)`;
                seat.innerHTML = `
                    <div class="player-info">
                        <span class="player-name">${gameState.players[i].name}</span>
                        <span class="player-chips">${gameState.players[i].chips}</span>
                    </div>
                    <div class="player-cards" id="player-cards-${i}"></div>
                    <div class="player-bet" id="player-bet-${i}"></div>
                    <div class="player-action" id="player-action-${i}"></div>
                `;
                container.appendChild(seat);
            }
        }

        // ==================== æ–°æ¸¸æˆ ====================
        function newGame() {
            // é‡ç½®çŠ¶æ€
            gameState.round++;
            gameState.phase = 'preflop';
            gameState.pot = 0;
            gameState.currentBet = 0;
            gameState.minRaise = gameConfig.bigBlind;
            gameState.lastRaiser = -1;
            gameState.communityCards = [];
            gameState.deck = createDeck();

            // ç§»åŠ¨åº„å®¶ä½ç½®
            gameState.dealerIndex = (gameState.dealerIndex + 1) % gameState.players.length;

            // é‡ç½®ç©å®¶
            gameState.players.forEach(p => {
                if (p.chips <= 0) {
                    p.chips = gameConfig.startingChips; // é‡ç½®ç­¹ç 
                }
                p.reset();
            });

            // å‘ç‰Œ
            gameState.players.forEach(p => {
                p.cards = [gameState.deck.pop(), gameState.deck.pop()];
            });

            // ä¸‹ç›²æ³¨
            postBlinds();

            // è®¾ç½®ç¬¬ä¸€ä¸ªè¡ŒåŠ¨ç©å®¶ï¼ˆå¤§ç›²åé¢çš„äººï¼‰
            const sbIndex = (gameState.dealerIndex + 1) % gameState.players.length;
            const bbIndex = (gameState.dealerIndex + 2) % gameState.players.length;
            gameState.currentPlayerIndex = (bbIndex + 1) % gameState.players.length;
            gameState.lastRaiser = gameState.currentPlayerIndex;

            updateDisplay();
            showMessage('ç¬¬ ' + gameState.round + ' å›åˆå¼€å§‹ï¼');

            // å¼€å§‹ç¬¬ä¸€ä¸ªç©å®¶çš„å›åˆ
            setTimeout(() => processTurn(), 1000);
        }

        function postBlinds() {
            const sbIndex = (gameState.dealerIndex + 1) % gameState.players.length;
            const bbIndex = (gameState.dealerIndex + 2) % gameState.players.length;

            placeBet(sbIndex, gameConfig.smallBlind);
            placeBet(bbIndex, gameConfig.bigBlind);

            gameState.players[sbIndex].lastAction = 'å°ç›²';
            gameState.players[bbIndex].lastAction = 'å¤§ç›²';
        }

        function placeBet(playerIndex, amount) {
            const player = gameState.players[playerIndex];
            const actualBet = Math.min(amount, player.chips);

            player.chips -= actualBet;
            player.currentBet += actualBet;
            gameState.pot += actualBet;

            if (actualBet > gameState.currentBet) {
                gameState.currentBet = actualBet;
            }

            if (player.chips === 0) {
                player.allIn = true;
            }

            updateDisplay();
        }

        // ==================== å›åˆå¤„ç† ====================
        function processTurn() {
            // æ£€æŸ¥æ˜¯å¦åªå‰©ä¸€ä¸ªç©å®¶
            const activePlayers = gameState.players.filter(p => !p.folded);
            if (activePlayers.length === 1) {
                endRound(activePlayers[0]);
                return;
            }

            // æ£€æŸ¥å›åˆæ˜¯å¦ç»“æŸ
            if (isRoundComplete()) {
                nextPhase();
                return;
            }

            const player = gameState.players[gameState.currentPlayerIndex];

            // è·³è¿‡å…¨æŠ¼ç©å®¶
            if (player.allIn || player.folded) {
                nextPlayer();
                return;
            }

            updateDisplay();

            if (player.isHuman) {
                enableControls();
                showMessage('è½®åˆ°ä½ äº†ï¼');
            } else {
                disableControls();
                setTimeout(() => aiTurn(player), 1000);
            }
        }

        function aiTurn(player) {
            const callAmount = gameState.currentBet - player.currentBet;
            const potOdds = callAmount / (gameState.pot + callAmount);
            const handStrength = evaluateHandStrength(player);
            const personality = player.personality;

            // è®¡ç®—éšæœºå› ç´ 
            const random = Math.random();
            let action;

            // å†³ç­–é€»è¾‘
            if (callAmount === 0) {
                // å¯ä»¥è¿‡ç‰Œ
                if (handStrength > 0.6 && random < personality.aggression) {
                    action = 'raise';
                } else {
                    action = 'check';
                }
            } else {
                // éœ€è¦è·Ÿæ³¨
                if (handStrength < personality.foldThreshold && random > personality.bluffChance) {
                    action = 'fold';
                } else if (handStrength > 0.7 && random < personality.aggression) {
                    action = 'raise';
                } else if (callAmount > player.chips * 0.5 && handStrength < 0.5) {
                    action = random < 0.5 ? 'fold' : 'call';
                } else {
                    action = 'call';
                }
            }

            // æ‰§è¡ŒåŠ¨ä½œ
            executeAction(player, action);
        }

        function executeAction(player, action) {
            const callAmount = gameState.currentBet - player.currentBet;

            switch (action) {
                case 'fold':
                    player.folded = true;
                    player.lastAction = 'å¼ƒç‰Œ';
                    showMessage(`${player.name} å¼ƒç‰Œ`);
                    break;

                case 'check':
                    player.lastAction = 'è¿‡ç‰Œ';
                    showMessage(`${player.name} è¿‡ç‰Œ`);
                    break;

                case 'call':
                    placeBet(player.id, callAmount);
                    player.lastAction = 'è·Ÿæ³¨';
                    showMessage(`${player.name} è·Ÿæ³¨ ${callAmount}`);
                    break;

                case 'raise':
                    const raiseAmount = callAmount + gameConfig.bigBlind * 2;
                    if (raiseAmount <= player.chips) {
                        placeBet(player.id, raiseAmount);
                        player.lastAction = 'åŠ æ³¨';
                        gameState.lastRaiser = player.id;
                        showMessage(`${player.name} åŠ æ³¨åˆ° ${player.currentBet}`);
                    } else {
                        // ç­¹ç ä¸è¶³ï¼Œæ‰§è¡Œå…¨æŠ¼
                        placeBet(player.id, player.chips);
                        player.lastAction = 'å…¨æŠ¼';
                        showMessage(`${player.name} å…¨æŠ¼`);
                    }
                    break;

                case 'allin':
                    placeBet(player.id, player.chips);
                    player.lastAction = 'å…¨æŠ¼';
                    showMessage(`${player.name} å…¨æŠ¼`);
                    break;
            }

            updateDisplay();
            setTimeout(() => nextPlayer(), 500);
        }

        function playerAction(action) {
            disableControls();
            const player = gameState.players[gameState.currentPlayerIndex];
            executeAction(player, action);
        }

        function nextPlayer() {
            // æ‰¾åˆ°ä¸‹ä¸€ä¸ªæœªå¼ƒç‰Œã€æœªå…¨æŠ¼çš„ç©å®¶
            let nextIndex = gameState.currentPlayerIndex;
            let loopCount = 0;

            do {
                nextIndex = (nextIndex + 1) % gameState.players.length;
                loopCount++;
            } while (
                loopCount <= gameState.players.length &&
                (gameState.players[nextIndex].folded || gameState.players[nextIndex].allIn)
            );

            gameState.currentPlayerIndex = nextIndex;
            processTurn();
        }

        function isRoundComplete() {
            // æ£€æŸ¥æ‰€æœ‰æ´»è·ƒç©å®¶çš„ä¸‹æ³¨æ˜¯å¦ç›¸ç­‰ï¼Œä¸”æœ€åä¸€ä¸ªåŠ æ³¨è€…å·²è¡ŒåŠ¨
            const activePlayers = gameState.players.filter(p => !p.folded && !p.allIn);
            if (activePlayers.length <= 1) return true;

            const firstBet = activePlayers[0].currentBet;
            const allMatched = activePlayers.every(p => p.currentBet === firstBet);
            const raiserActed = gameState.currentPlayerIndex === gameState.lastRaiser;

            return allMatched && raiserActed && gameState.currentBet > 0;
        }

        // ==================== é˜¶æ®µæ¨è¿› ====================
        function nextPhase() {
            // é‡ç½®å½“å‰è½®ä¸‹æ³¨
            gameState.players.forEach(p => p.currentBet = 0);
            gameState.currentBet = 0;
            gameState.lastRaiser = (gameState.dealerIndex + 1) % gameState.players.length;
            gameState.currentPlayerIndex = gameState.lastRaiser;

            switch (gameState.phase) {
                case 'preflop':
                    gameState.phase = 'flop';
                    // å‘ä¸‰å¼ å…¬å…±ç‰Œ
                    gameState.communityCards.push(gameState.deck.pop(), gameState.deck.pop(), gameState.deck.pop());
                    showMessage('ç¿»ç‰Œåœˆï¼');
                    break;

                case 'flop':
                    gameState.phase = 'turn';
                    gameState.communityCards.push(gameState.deck.pop());
                    showMessage('è½¬ç‰Œåœˆï¼');
                    break;

                case 'turn':
                    gameState.phase = 'river';
                    gameState.communityCards.push(gameState.deck.pop());
                    showMessage('æ²³ç‰Œåœˆï¼');
                    break;

                case 'river':
                    showdown();
                    return;
            }

            updateDisplay();
            setTimeout(() => processTurn(), 1000);
        }

        // ==================== æ‘Šç‰Œ ====================
        function showdown() {
            gameState.phase = 'showdown';
            const activePlayers = gameState.players.filter(p => !p.folded);

            if (activePlayers.length === 1) {
                endRound(activePlayers[0]);
                return;
            }

            // è¯„ä¼°æ‰€æœ‰ç©å®¶çš„ç‰Œ
            let bestHand = null;
            let winners = [];

            for (const player of activePlayers) {
                const hand = evaluateHand([...player.cards, ...gameState.communityCards]);
                player.hand = hand;

                if (!bestHand || compareHands(hand, bestHand) > 0) {
                    bestHand = hand;
                    winners = [player];
                } else if (compareHands(hand, bestHand) === 0) {
                    winners.push(player);
                }
            }

            // æ˜¾ç¤ºæ‰€æœ‰ç©å®¶çš„ç‰Œ
            updateDisplay(true);

            // åˆ†é…åº•æ± 
            const winAmount = Math.floor(gameState.pot / winners.length);
            winners.forEach(w => w.chips += winAmount);

            let resultText = winners.length === 1
                ? `${winners[0].name} è·èƒœï¼${winners[0].hand.name}`
                : `å¹³å±€ï¼${winners.map(w => w.name).join(' & ')} å„èµ¢ ${winAmount}`;

            showMessage(`${resultText}`);

            // 3ç§’åå¯ä»¥å¼€å§‹æ–°æ¸¸æˆ
            setTimeout(() => {
                disableControls();
            }, 3000);
        }

        function endRound(winner) {
            winner.chips += gameState.pot;
            showMessage(`${winner.name} èµ¢å¾—åº•æ±  ${gameState.pot}ï¼`);
            gameState.phase = 'showdown';
            updateDisplay(true);
            disableControls();
        }

        // ==================== ç‰Œå‹è¯„ä¼° ====================
        function evaluateHand(cards) {
            const values = cards.map(c => c.value).sort((a, b) => b - a);
            const suits = cards.map(c => c.suit);

            const valueCounts = {};
            values.forEach(v => valueCounts[v] = (valueCounts[v] || 0) + 1);
            const counts = Object.values(valueCounts).sort((a, b) => b - a);

            const suitCounts = {};
            suits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1);
            const isFlush = Object.values(suitCounts).some(c => c >= 5);

            const uniqueValues = [...new Set(values)].sort((a, b) => b - a);
            const isStraight = checkStraight(uniqueValues);

            // åŒèŠ±é¡º
            if (isFlush && isStraight) return { rank: 9, name: 'åŒèŠ±é¡º', values };
            // å››æ¡
            if (counts[0] === 4) return { rank: 8, name: 'å››æ¡', values };
            // è‘«èŠ¦
            if (counts[0] === 3 && counts[1] >= 2) return { rank: 7, name: 'è‘«èŠ¦', values };
            // åŒèŠ±
            if (isFlush) return { rank: 6, name: 'åŒèŠ±', values };
            // é¡ºå­
            if (isStraight) return { rank: 5, name: 'é¡ºå­', values };
            // ä¸‰æ¡
            if (counts[0] === 3) return { rank: 4, name: 'ä¸‰æ¡', values };
            // ä¸¤å¯¹
            if (counts[0] === 2 && counts[1] === 2) return { rank: 3, name: 'ä¸¤å¯¹', values };
            // ä¸€å¯¹
            if (counts[0] === 2) return { rank: 2, name: 'ä¸€å¯¹', values };
            // é«˜ç‰Œ
            return { rank: 1, name: 'é«˜ç‰Œ', values };
        }

        function evaluateHandStrength(player) {
            if (gameState.communityCards.length === 0) {
                // ç¿»ç‰Œå‰ï¼Œæ ¹æ®æ‰‹ç‰Œè¯„ä¼°
                const c1 = player.cards[0];
                const c2 = player.cards[1];
                const isPair = c1.value === c2.value;
                const isSuited = c1.suit === c2.suit;
                const highCard = Math.max(c1.value, c2.value);

                let strength = highCard / 14 * 0.3;
                if (isPair) strength += 0.3;
                if (isSuited) strength += 0.1;
                if (Math.abs(c1.value - c2.value) <= 4) strength += 0.1;

                return Math.min(strength, 1);
            } else {
                const hand = evaluateHand([...player.cards, ...gameState.communityCards]);
                return hand.rank / 9;
            }
        }

        function checkStraight(values) {
            for (let i = 0; i <= values.length - 5; i++) {
                if (values[i] - values[i + 4] === 4) return true;
            }
            // A2345
            if (values.includes(14) && values.includes(2) && values.includes(3) && values.includes(4) && values.includes(5)) {
                return true;
            }
            return false;
        }

        function compareHands(hand1, hand2) {
            if (hand1.rank !== hand2.rank) {
                return hand1.rank - hand2.rank;
            }
            // ç›¸åŒç‰Œå‹ï¼Œæ¯”è¾ƒé«˜ç‰Œ
            for (let i = 0; i < Math.min(hand1.values.length, hand2.values.length); i++) {
                if (hand1.values[i] !== hand2.values[i]) {
                    return hand1.values[i] - hand2.values[i];
                }
            }
            return 0;
        }

        // ==================== å·¥å…·å‡½æ•° ====================
        function createDeck() {
            const deck = [];
            for (const suit of SUITS) {
                for (const rank of RANKS) {
                    deck.push({ suit, rank, value: RANK_VALUES[rank] });
                }
            }
            // æ´—ç‰Œ
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        function createCardElement(card, faceDown = false) {
            const div = document.createElement('div');
            div.className = 'card';

            if (faceDown) {
                div.classList.add('card-back');
                return div;
            }

            const isRed = card.suit === 'â™¥' || card.suit === 'â™¦';
            div.classList.add(isRed ? 'red' : 'black');

            div.innerHTML = `
                <span class="card-rank">${card.rank}</span>
                <span class="card-suit">${card.suit}</span>
            `;

            return div;
        }

        // ==================== æ˜¾ç¤ºæ›´æ–° ====================
        function updateDisplay(showAllCards = false) {
            // æ›´æ–°æ¸¸æˆä¿¡æ¯
            document.getElementById('round-num').textContent = gameState.round;
            document.getElementById('small-blind').textContent = gameConfig.smallBlind;
            document.getElementById('big-blind').textContent = gameConfig.bigBlind;
            document.getElementById('pot').textContent = gameState.pot;

            // æ›´æ–°é˜¶æ®µæ˜¾ç¤º
            const phaseNames = {
                'idle': 'ç­‰å¾…å¼€å§‹',
                'preflop': 'ç¿»ç‰Œå‰',
                'flop': 'ç¿»ç‰Œåœˆ',
                'turn': 'è½¬ç‰Œåœˆ',
                'river': 'æ²³ç‰Œåœˆ',
                'showdown': 'æ‘Šç‰Œ'
            };
            document.getElementById('phase-display').textContent = phaseNames[gameState.phase];

            // æ›´æ–°å…¬å…±ç‰Œ
            const communityDiv = document.getElementById('community-cards');
            communityDiv.innerHTML = '';
            for (let i = 0; i < 5; i++) {
                if (i < gameState.communityCards.length) {
                    communityDiv.appendChild(createCardElement(gameState.communityCards[i]));
                } else {
                    const backCard = document.createElement('div');
                    backCard.className = 'card card-back';
                    communityDiv.appendChild(backCard);
                }
            }

            // æ›´æ–°ç©å®¶åº§ä½
            gameState.players.forEach((player, index) => {
                const seat = document.getElementById(`player-seat-${index}`);
                const cardsDiv = document.getElementById(`player-cards-${index}`);
                const betDiv = document.getElementById(`player-bet-${index}`);
                const actionDiv = document.getElementById(`player-action-${index}`);

                // æ›´æ–°åº§ä½çŠ¶æ€
                seat.classList.toggle('active', index === gameState.currentPlayerIndex && gameState.phase !== 'idle' && gameState.phase !== 'showdown');
                seat.classList.toggle('folded', player.folded);
                seat.classList.toggle('dealer', index === gameState.dealerIndex);

                // æ›´æ–°ç­¹ç æ˜¾ç¤º
                seat.querySelector('.player-chips').textContent = player.chips;

                // æ›´æ–°æ‰‹ç‰Œ
                cardsDiv.innerHTML = '';
                if (player.cards.length > 0) {
                    const showCards = player.isHuman || showAllCards || gameState.phase === 'showdown';
                    player.cards.forEach(card => {
                        cardsDiv.appendChild(createCardElement(card, !showCards));
                    });
                }

                // æ›´æ–°ä¸‹æ³¨æ˜¾ç¤º
                betDiv.textContent = player.currentBet > 0 ? `ä¸‹æ³¨: ${player.currentBet}` : '';
                if (player.allIn) betDiv.textContent = 'å…¨æŠ¼ï¼';

                // æ›´æ–°åŠ¨ä½œæ˜¾ç¤º
                actionDiv.textContent = player.lastAction;
            });

            // æ›´æ–°è·Ÿæ³¨é‡‘é¢
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            if (currentPlayer && gameState.phase !== 'idle' && gameState.phase !== 'showdown') {
                const callAmount = gameState.currentBet - currentPlayer.currentBet;
                document.getElementById('call-amount').textContent = callAmount > 0 ? callAmount : '';
            }

            // æ›´æ–°çœŸäººç©å®¶çš„æ‰‹ç‰Œå¼ºåº¦
            updateHandStrength();
        }

        function updateHandStrength() {
            const humanPlayer = gameState.players.find(p => p.isHuman);
            if (!humanPlayer || humanPlayer.cards.length === 0) {
                document.getElementById('hand-strength').textContent = '';
                return;
            }

            const hand = evaluateHand([...humanPlayer.cards, ...gameState.communityCards]);
            document.getElementById('hand-strength').textContent = `å½“å‰ç‰Œå‹: ${hand.name}`;
        }

        function showMessage(msg) {
            document.getElementById('message').textContent = msg;
        }

        function enableControls() {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const callAmount = gameState.currentBet - currentPlayer.currentBet;

            document.getElementById('btn-fold').disabled = false;
            document.getElementById('btn-check').disabled = callAmount > 0;
            document.getElementById('btn-call').disabled = callAmount === 0 || callAmount > currentPlayer.chips;
            document.getElementById('btn-raise').disabled = currentPlayer.chips <= callAmount;
            document.getElementById('btn-allin').disabled = false;
            document.getElementById('btn-new-game').disabled = gameState.phase !== 'showdown';
        }

        function disableControls() {
            document.getElementById('btn-fold').disabled = true;
            document.getElementById('btn-check').disabled = true;
            document.getElementById('btn-call').disabled = true;
            document.getElementById('btn-raise').disabled = true;
            document.getElementById('btn-allin').disabled = true;
            document.getElementById('btn-new-game').disabled = false;
        }

        // åˆå§‹åŒ–
        init();
    </script>
</body>
</html>
